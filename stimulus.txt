00000000_11_00000011__00000110_0000_1_1_1_z0000000_000001001_0_000_0_0 //add
11000000_11_11111111__11111111_0000_1_1_1_z0000000_100000000_1_000_0_0 //add
00000001_11_00000111__00000110_0001_1_1_1_z0000000_000000001_0_000_0_0 //sub
11000001_11_00000111__00000110_0001_0_1_1_z0000000_000000000_0_000_0_0 //sub(invalid)
11100001_11_00000111__00000110_0001_1_0_1_z0000000_000000000_0_000_0_0 //sub(invalid)
00010001_11_00000111__00000110_0001_0_0_1_z0000000_000000000_0_000_0_0 //sub(invalid)
00000001_11_00000111__00000110_0001_0_0_0_z0000000_000000000_0_000_0_0 //sub(invalid)
01000001_00_00000111__00000110_0001_1_1_1_z0000000_000000001_0_000_0_0 //sub(invalid inputs)
00000010_11_00000111__00000110_0010_1_1_1_z0000000_000001110_0_000_0_0 //add_cin
00000011_11_00000001__00000101_0011_1_1_1_z1111111_111111011_0_000_1_0 //sub_cin(failed),giving cout as high..instead of overflow
00000100_01_00000001__00000000_0100_1_1_1_z0000000_000000010_0_000_0_0 //inc_A
00000100_01_00000000__00000001_0110_1_1_1_z0000000_000000010_0_000_0_0 //inc_B
10000100_01_11111111__00000000_0100_1_1_1_z0000000_000000000_0_000_0_0 //inc_A(limitation)
01000101_10_00000001__11111111_0110_1_1_1_z0000000_000000011_0_000_0_0 //inc_B(limitation)
10000110_01_00000001__00000001_0101_1_1_1_z0000000_000000000_0_000_0_0 //dec_A
10000110_01_00000000__00000001_0101_1_1_1_z0000000_000000000_0_000_0_0 //dec_A limitation
00000111_10_00000011__00000111_0111_1_1_1_z0000000_000000110_0_000_0_0 //dec_B
10000111_10_00000011__00000111_0111_1_1_1_z0000000_000000000_0_000_0_0 //dec_B(limitation)
00001000_11_00000100__00000100_1000_1_1_1_z0000000_000000000_0_100_0_0 // Test 8: CMP
00001001_11_00000011__00000011_1001_1_1_1_z0000000_000010010_0_000_0_0 // Test 9: MUL_IN
00001010_11_00000011__00000010_1010_1_1_1_z0000000_000001111_0_000_0_0 // Test 10: MUL_S
00001011_11_00000111__00000001_1011_1_1_1_z0000000_000001000_0_010_0_0 // Test 11: ADD_S
00001100_11_00001011__00001000_1100_1_1_1_z0000000_000000011_0_010_0_0 // Test 12: SUB_S
00001101_11_00001111__00000011_0000_0_1_0_z0000000_000000011_0_000_0_0 // AND: 1111 & 0011 = 0011
00001101_01_00001111__00000011_0000_0_1_0_z0000000_000000000_0_000_0_1  //AND ERR CONDITION
10001110_11_00001111__00000011_0001_0_1_0_z0000000_111111100_0_000_0_0 // NAND: ~(1111 & 0011) = 11111100
10001110_01_00001111__00000011_0001_0_1_0_z0000000_000000000_0_000_0_1 //NAND ERR CONDITION
00001111_11_00001100__00000011_0010_0_1_0_z0000000_000001111_0_000_0_0 // OR: 1100 | 0011 = 1111
10001111_01_00001100__00000011_0010_0_1_0_z0000000_000000000_0_000_0_1 //OR ERR CONDITION
00010000_11_00001100__00000011_0011_0_1_0_z1111111_111110000_0_000_0_0 // NOR: ~(1100 | 0011) = 00000000
10010000_01_00001100__00000011_0011_0_1_0_z1111111_000000000_0_000_0_1 // NOR ERR CONDITION
00010001_11_00001100__00000011_0100_0_1_0_z0000000_000001111_0_000_0_0 // XOR: 1100 ^ 0011 = 1111
10010001_01_00001100__00000011_0100_0_1_0_z0000000_000000000_0_000_0_1 //XOR ERR CONDITION
00010010_11_00001100__00000011_0101_0_1_0_z1111111_111110000_0_000_0_0 // XNOR: ~(1100 ^ 0011) = 00000000OR: ~(1100 ^ 0011) = 00000000
10010010_01_00001100__00000011_0101_0_1_0_z1111111_000000000_0_000_0_1 // XNOR ERR CONDITION
00010011_01_00001100__00000000_0110_0_1_0_z1111111_111110011_0_000_0_0 // NOT A = ~1100
10010011_00_00001100__00000000_0110_0_1_0_z0000000_000000000_0_000_0_1 //NOT ERR CONDITION
00010100_10_00000000__00001100_0111_0_1_0_z1111111_111110011_0_000_0_0 // NOT B = ~1100
00010101_01_00000100__00000000_1000_0_1_0_z0000000_000001000_0_000_0_0 // A << 1: 0100 << 1 = 1000
00010110_01_00000100__00000000_1001_0_1_0_z0000000_000000010_0_000_0_0 // A >> 1: 0100 >> 1 = 0010
00010111_10_00000000__00000100_1010_0_1_0_z0000000_000001000_0_000_0_0 // B << 1: 0100 << 1 = 1000
00011000_10_00000000__00000100_1011_0_1_0_z0000000_000000010_0_000_0_0 // B >> 1: 0100 >> 1 = 0010
00011001_01_10011001__00000011_1101_0_1_0_z0000000_010011001_0_000_0_0 // ROR by 3
10011001_11_10011001__00000011_1101_0_1_0_z0000000_000000000_0_000_0_1 //ROR ERR
00011010_01_10011001__00000011_1100_0_1_0_z0000000_011001100_0_000_0_0 // ROl by 3
10011010_11_10011001__00000011_1100_0_1_0_z0000000_000000000_0_000_0_1 //ROL ERR
00011011_01_10011001__10000011_1100_0_1_0_z0000000_000000000_0_000_0_1 // ROL invalid: OPB[7:4]!=0 → ERR=1
00011100_01_10011001__10000011_1101_0_1_0_z0000000_000000000_0_000_0_1 // ROR invalid: OPB[7:4]!=0 → ERR=1
00011101_11_11111111__00000001_0000_1_1_1_z0000000_100000000_1_000_0_0 // ADD: 255 + 1 = 256 → COUT = 1(giving cout as 0)
00011110_11_00000000__00000001_0001_1_1_1_z1111111_111111111_0_000_1_0 // SUB: 0 - 1 = -1 (255)(failed)
00011111_11_10000000__10000000_1011_1_1_1_z0000000_000000000_0_100_1_0 // ADD_CIN: -128 + -128 + CIN → signed overflow
00100000_11_01111111__00000001_1100_1_1_1_z0000000_011111110_0_000_0_0 // SUB_CIN: 127 - 1 - 1 = 125 → no overflow
00100001_01_11111111__00000000_0100_1_1_1_z0000000_000000000_0_000_0_0 // INC_A: 255 + 1 = 0 → wrap(not working limitation)
00100010_10_00000000__11111111_0110_1_1_1_z0000000_000000000_0_000_0_0 // INC_B: 255 + 1 = 0 → wrap(not working linmitation)
00100011_01_00000000__00000000_0101_1_1_1_z1111111_111111111_0_000_0_0 // DEC_A: 0 - 1 = 255(not working)
00100100_10_00000000__00000000_0111_1_1_1_z1111111_111111111_0_000_0_0 // DEC_B: 0 - 1 = 255(not working)
00100101_11_11111111__11111111_1000_1_1_1_z0000000_000000000_0_100_0_0 // CMP: A == B == 255 → E = 1
00100110_11_00000001__11111111_1000_1_1_1_z0000000_000000000_0_001_0_0 // CMP: A < B → L = 1
00100111_11_11111111__00000001_1000_1_1_1_z0000000_000000000_0_010_0_0 // CMP: A > B → G = 1
00101000_11_11111111__11111111_1011_0_1_1_z0000000_111111110_1_100_0_0 // S_ADD: 127 + 127 →  overflow(not giving)
00101001_11_10000000__10000000_1100_0_1_1_z0000000_000000000_0_100_0_0 // S_SUB: -128 - (-128) = 0, no overflow
00100110_00_00000011__00000110_0000_0_1_1_z0000000_000000000_0_000_0_1 // INP_VALID = 00 → No action, default case
00100111_01_00000011__00000110_0010_1_1_1_z0000000_000000000_0_000_0_1 // ADD_CIN with only OPA (should raise error)
00101000_10_00000000__00000001_0011_1_1_1_z0000000_000000000_0_000_0_1 // SUB_CIN with only OPB (should raise error)
00101001_11_10000000__10000000_1011_0_1_1_z0000000_000000000_1_100_1_0 // Signed ADD (overflow) -128 + -128
00101010_11_01111111__01111111_1100_0_1_1_z0000000_000000000_0_100_1_0 // Signed SUB (overflow) 127 - (-127)
00101011_11_00001111__00000000_0000_0_0_1_z0000000_000011111_0_000_0_0 // CE = 0: inputs present, but operation skipped
00101100_11_11111111__11111111_0100_0_1_0_z0000000_000000000_0_000_0_0 // XNOR of all ones
00101101_01_11110000__00000000_0110_0_1_0_z0000000_100001111_0_000_0_0 // NOT A with high bits set
00101110_10_00000000__11110000_0111_0_1_0_z0000000_100001111_0_000_0_0 // NOT B, result should be complement
00101111_11_00000101__00000001_1111_1_1_1_z0000000_000000000_0_000_0_0 // CMD = 15: undefined operation, should default
00110000_11_00000001__00000000_0000_0_1_1_z0000000_000000001_0_000_0_0 // ADD: smallest nonzero addition
00110001_11_11111111__00000001_0000_0_1_1_z0000000_100000000_1_000_0_0 // ADD: max value + small = carry out
00110010_11_11111111__11111111_0001_0_1_1_z0000000_000000000_0_000_0_0 // SUB: equal max - max = zero
00100110_11_01111111__00000001_1011_0_1_1_z0000000_010000000_0_000_1_0  // Signed ADD Overflow: 127 + 1 → overflow
00100111_11_10000000__11111111_1011_0_1_1_z0000000_011111111_0_000_1_0  // Signed ADD Overflow: -128 + (-1)
00101000_11_01111111__11111111_1011_0_1_1_z0000000_011111110_0_100_0_0  // Signed ADD No Overflow: 127 + (-1)
00101001_11_10000000__00000001_1011_0_1_1_z0000000_100000001_0_000_0_0  // Signed ADD No Overflow: -128 + 1
00101010_11_10000000__00000001_1100_0_1_1_z0000000_011111111_0_000_1_0  // Signed SUB Overflow: -128 - 1
00101011_11_00000001__10000000_1100_0_1_1_z0000000_100000001_0_000_1_0  // Signed SUB Overflow: 1 - (-128)
00101100_11_00000010__00000001_1100_0_1_1_z0000000_000000001_0_100_0_0  // Signed SUB No Overflow: 2 - 1
00101101_11_10000000__01111111_1100_0_1_1_z0000000_000000001_0_001_0_0  // Signed SUB No Overflow: -128 - 127
01110110_11_00000010__00000011_1001_0_0_1_z0000000_000001100_0_000_0_0  // MUL_INC test with CE=0, cmd9_done should be 1
00110111_11_00000001__00000001_1001_0_1_1_z0000000_000000000_0_000_0_0 // cycle 1 - begin CMD 9
11101000_00_00000001__00000001_1001_0_1_1_z0000000_000000000_0_000_0_0 // cycle 2 - force invalid INP_VALID → st1 → st0
00101001_11_10000010__00000010_1100_0_1_1_z0000000_100000000_0_000_1_0 // Signed SUB: -126 - 2 = -128 → same MSB
00101110_11_00000101__00000100_1001_0_1_1_z0000000_000000000_0_000_0_0 // Start MUL_INC (cmd=9)
00101111_11_00000011__00000001_0000_0_1_1_z0000000_000000100_0_000_0_0 // On next cycle, give ADD (cmd=0) before completion
